Index: __tests__/routes/keys.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const request = require('supertest');\nconst { createApp } = require('../../config/app');\nconst {\n    createTestKey,\n    createTestHash,\n    deleteTestKeys,\n    keyExists,\n    getKeyValue,\n    getKeyTTL\n} = require('../helpers/testHelpers');\n\ndescribe('Keys Routes', () => {\n    const app = createApp();\n    const testConnectionId = global.TEST_CONNECTION_ID;\n\n    beforeEach(async () => {\n        await deleteTestKeys('test:keys:*', testConnectionId);\n    });\n\n    afterEach(async () => {\n        await deleteTestKeys('test:keys:*', testConnectionId);\n    });\n\n    describe('GET /api/keys', () => {\n        test('should return keys with pagination', async () => {\n            await createTestKey('test:keys:one', 'value1', testConnectionId);\n            await createTestKey('test:keys:two', 'value2', testConnectionId);\n\n            const response = await request(app)\n                .get('/api/keys')\n                .query({ env: testConnectionId, pattern: 'test:keys:*' })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('keys');\n            expect(response.body).toHaveProperty('cursors');\n            expect(response.body).toHaveProperty('hasMore');\n            expect(Array.isArray(response.body.keys)).toBe(true);\n            expect(response.body.keys.length).toBeGreaterThanOrEqual(2);\n        });\n\n        test('should filter keys by pattern', async () => {\n            await createTestKey('test:keys:match:a', 'value', testConnectionId);\n            await createTestKey('test:keys:match:b', 'value', testConnectionId);\n            await createTestKey('test:keys:nomatch', 'value', testConnectionId);\n\n            const response = await request(app)\n                .get('/api/keys')\n                .query({ env: testConnectionId, pattern: 'test:keys:match:*' })\n                .expect(200);\n\n            expect(response.body.keys.length).toBeGreaterThanOrEqual(2);\n            response.body.keys.forEach((key) => {\n                expect(key).toMatch(/test:keys:match:/);\n            });\n        });\n\n        test('should handle custom count parameter', async () => {\n            for (let i = 0; i < 5; i++) {\n                await createTestKey(\n                    `test:keys:count:${i}`,\n                    'value',\n                    testConnectionId\n                );\n            }\n\n            const response = await request(app)\n                .get('/api/keys')\n                .query({\n                    env: testConnectionId,\n                    pattern: 'test:keys:count:*',\n                    count: 10\n                })\n                .expect(200);\n\n            expect(response.body.keys.length).toBeGreaterThanOrEqual(5);\n        });\n    });\n\n    describe('GET /api/allkeys', () => {\n        test('should return all keys matching pattern', async () => {\n            await createTestKey('test:keys:all:1', 'value', testConnectionId);\n            await createTestKey('test:keys:all:2', 'value', testConnectionId);\n            await createTestKey('test:keys:all:3', 'value', testConnectionId);\n\n            const response = await request(app)\n                .get('/api/allkeys')\n                .query({ env: testConnectionId, pattern: 'test:keys:all:*' })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('keys');\n            expect(response.body.keys.length).toBe(3);\n        });\n    });\n\n    describe('GET /api/keys/:key', () => {\n        test('should get string key value', async () => {\n            await createTestKey(\n                'test:keys:get',\n                'test-value',\n                testConnectionId\n            );\n\n            const response = await request(app)\n                .get('/api/keys/test:keys:get')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('key', 'test:keys:get');\n            expect(response.body).toHaveProperty('type', 'string');\n            expect(response.body).toHaveProperty('value');\n            expect(response.body.value.trim()).toBe('test-value');\n        });\n\n        test('should get key with TTL', async () => {\n            await createTestKey('test:keys:ttl', 'value', testConnectionId, 60);\n\n            const response = await request(app)\n                .get('/api/keys/test:keys:ttl')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('ttl');\n            expect(response.body.ttl).toBeGreaterThan(0);\n            expect(response.body.ttl).toBeLessThanOrEqual(60);\n        });\n\n        test('should get hash key', async () => {\n            await createTestHash(\n                'test:keys:hash',\n                {\n                    field1: 'value1',\n                    field2: 'value2'\n                },\n                testConnectionId\n            );\n\n            const response = await request(app)\n                .get('/api/keys/test:keys:hash')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body.type).toBe('hash');\n            expect(response.body.value).toBeDefined();\n        });\n\n        test('should return 404 for non-existent key', async () => {\n            const response = await request(app)\n                .get('/api/keys/test:keys:nonexistent')\n                .query({ env: testConnectionId })\n                .expect(404);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('GET /api/keys/:key/exists', () => {\n        test('should check if key exists', async () => {\n            await createTestKey('test:keys:exists', 'value', testConnectionId);\n\n            const response = await request(app)\n                .get('/api/keys/test:keys:exists/exists')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toEqual({ exists: true });\n        });\n\n        test('should return false for non-existent key', async () => {\n            const response = await request(app)\n                .get('/api/keys/test:keys:notexists/exists')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toEqual({ exists: false });\n        });\n    });\n\n    describe('POST /api/keys', () => {\n        test('should create new string key', async () => {\n            const response = await request(app)\n                .post('/api/keys')\n                .query({ env: testConnectionId })\n                .send({\n                    key: 'test:keys:new',\n                    value: 'new-value'\n                })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('success', true);\n            expect(response.body).toHaveProperty('key', 'test:keys:new');\n\n            const exists = await keyExists('test:keys:new', testConnectionId);\n            expect(exists).toBe(true);\n\n            const value = await getKeyValue('test:keys:new', testConnectionId);\n            expect(value.trim()).toBe('new-value');\n        });\n\n        test('should create key with expiry', async () => {\n            const response = await request(app)\n                .post('/api/keys')\n                .query({ env: testConnectionId })\n                .send({\n                    key: 'test:keys:expiry',\n                    value: 'value',\n                    expiry: 60\n                })\n                .expect(200);\n\n            expect(response.body.success).toBe(true);\n\n            const ttl = await getKeyTTL('test:keys:expiry', testConnectionId);\n            expect(ttl).toBeGreaterThan(0);\n            expect(ttl).toBeLessThanOrEqual(60);\n        });\n\n        test('should handle JSON object values', async () => {\n            const jsonValue = { name: 'test', count: 42 };\n\n            const response = await request(app)\n                .post('/api/keys')\n                .query({ env: testConnectionId })\n                .send({\n                    key: 'test:keys:json',\n                    value: jsonValue\n                })\n                .expect(200);\n\n            expect(response.body.success).toBe(true);\n\n            const value = await getKeyValue('test:keys:json', testConnectionId);\n            expect(JSON.parse(value.trim())).toEqual(jsonValue);\n        });\n\n        test('should return 400 for missing key', async () => {\n            const response = await request(app)\n                .post('/api/keys')\n                .query({ env: testConnectionId })\n                .send({ value: 'value' })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should return 400 for missing value', async () => {\n            const response = await request(app)\n                .post('/api/keys')\n                .query({ env: testConnectionId })\n                .send({ key: 'test:key' })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('DELETE /api/keys/:key', () => {\n        test('should delete existing key', async () => {\n            await createTestKey('test:keys:delete', 'value', testConnectionId);\n\n            const response = await request(app)\n                .delete('/api/keys/test:keys:delete')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('deleted', true);\n            expect(response.body).toHaveProperty('key', 'test:keys:delete');\n\n            const exists = await keyExists(\n                'test:keys:delete',\n                testConnectionId\n            );\n            expect(exists).toBe(false);\n        });\n\n        test('should handle non-existent key gracefully', async () => {\n            const response = await request(app)\n                .delete('/api/keys/test:keys:notexist')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body.deleted).toBe(false);\n            expect(response.body.count).toBe(0);\n        });\n    });\n\n    describe('DELETE /api/allkeys', () => {\n        test('should delete keys by pattern', async () => {\n            await createTestKey('test:keys:batch:1', 'value', testConnectionId);\n            await createTestKey('test:keys:batch:2', 'value', testConnectionId);\n            await createTestKey('test:keys:batch:3', 'value', testConnectionId);\n\n            const response = await request(app)\n                .delete('/api/allkeys')\n                .query({ env: testConnectionId, pattern: 'test:keys:batch:*' })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('count');\n            expect(response.body.count).toBeGreaterThanOrEqual(3);\n\n            const exists1 = await keyExists(\n                'test:keys:batch:1',\n                testConnectionId\n            );\n            const exists2 = await keyExists(\n                'test:keys:batch:2',\n                testConnectionId\n            );\n            const exists3 = await keyExists(\n                'test:keys:batch:3',\n                testConnectionId\n            );\n\n            expect(exists1).toBe(false);\n            expect(exists2).toBe(false);\n            expect(exists3).toBe(false);\n        });\n\n        test('should return 400 when pattern is missing', async () => {\n            const response = await request(app)\n                .delete('/api/allkeys')\n                .query({ env: testConnectionId })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should handle pattern with no matches', async () => {\n            const response = await request(app)\n                .delete('/api/allkeys')\n                .query({\n                    env: testConnectionId,\n                    pattern: 'test:keys:nomatch:*'\n                })\n                .expect(200);\n\n            expect(response.body.count).toBe(0);\n        });\n    });\n\n    describe('GET /api/keycount', () => {\n        test('should return key count', async () => {\n            await createTestKey('test:keys:count:1', 'value', testConnectionId);\n\n            const response = await request(app)\n                .get('/api/keycount')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('count');\n            expect(typeof response.body.count).toBe('number');\n            expect(response.body.count).toBeGreaterThanOrEqual(1);\n        });\n    });\n\n    describe('POST /api/keys/:key/rename', () => {\n        test('should rename key', async () => {\n            await createTestKey('test:keys:oldname', 'value', testConnectionId);\n\n            const response = await request(app)\n                .post('/api/keys/test:keys:oldname/rename')\n                .query({ env: testConnectionId })\n                .send({ newKey: 'test:keys:newname' })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('oldKey', 'test:keys:oldname');\n            expect(response.body).toHaveProperty('newKey', 'test:keys:newname');\n\n            const oldExists = await keyExists(\n                'test:keys:oldname',\n                testConnectionId\n            );\n            const newExists = await keyExists(\n                'test:keys:newname',\n                testConnectionId\n            );\n\n            expect(oldExists).toBe(false);\n            expect(newExists).toBe(true);\n\n            await deleteTestKeys('test:keys:newname', testConnectionId);\n        });\n\n        test('should return 400 when newKey is missing', async () => {\n            const response = await request(app)\n                .post('/api/keys/test:keys:some/rename')\n                .query({ env: testConnectionId })\n                .send({})\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('POST /api/keys/:key/expire', () => {\n        test('should set expiry on key', async () => {\n            await createTestKey(\n                'test:keys:setexpiry',\n                'value',\n                testConnectionId\n            );\n\n            const response = await request(app)\n                .post('/api/keys/test:keys:setexpiry/expire')\n                .query({ env: testConnectionId })\n                .send({ seconds: 120 })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('key', 'test:keys:setexpiry');\n            expect(response.body).toHaveProperty('ttl', 120);\n\n            const ttl = await getKeyTTL(\n                'test:keys:setexpiry',\n                testConnectionId\n            );\n            expect(ttl).toBeGreaterThan(0);\n            expect(ttl).toBeLessThanOrEqual(120);\n        });\n\n        test('should remove expiry with negative seconds', async () => {\n            await createTestKey(\n                'test:keys:persist',\n                'value',\n                testConnectionId,\n                60\n            );\n\n            await request(app)\n                .post('/api/keys/test:keys:persist/expire')\n                .query({ env: testConnectionId })\n                .send({ seconds: -1 })\n                .expect(200);\n\n            const ttl = await getKeyTTL('test:keys:persist', testConnectionId);\n            expect(ttl).toBe(-1);\n        });\n\n        test('should return 400 when seconds is missing', async () => {\n            const response = await request(app)\n                .post('/api/keys/test:keys:some/expire')\n                .query({ env: testConnectionId })\n                .send({})\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('POST /api/keys/:key/copy', () => {\n        test('should copy string key within same environment', async () => {\n            await createTestKey(\n                'test:keys:source',\n                'source-value',\n                testConnectionId\n            );\n\n            const response = await request(app)\n                .post('/api/keys/test:keys:source/copy')\n                .query({ env: testConnectionId })\n                .send({\n                    targetKey: 'test:keys:target',\n                    targetEnv: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('result');\n            expect(response.body.sourceKey).toBe('test:keys:source');\n            expect(response.body.targetKey).toBe('test:keys:target');\n\n            const targetExists = await keyExists(\n                'test:keys:target',\n                testConnectionId\n            );\n            expect(targetExists).toBe(true);\n\n            const targetValue = await getKeyValue(\n                'test:keys:target',\n                testConnectionId\n            );\n            expect(targetValue.trim()).toBe('source-value');\n        });\n\n        test('should copy key with TTL', async () => {\n            await createTestKey(\n                'test:keys:source-ttl',\n                'value',\n                testConnectionId,\n                120\n            );\n\n            const response = await request(app)\n                .post('/api/keys/test:keys:source-ttl/copy')\n                .query({ env: testConnectionId })\n                .send({\n                    targetKey: 'test:keys:target-ttl',\n                    targetEnv: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body.result).toContain('successfully');\n\n            const ttl = await getKeyTTL(\n                'test:keys:target-ttl',\n                testConnectionId\n            );\n            expect(ttl).toBeGreaterThan(0);\n            expect(ttl).toBeLessThanOrEqual(120);\n        });\n\n        test('should return 400 when targetKey is missing', async () => {\n            const response = await request(app)\n                .post('/api/keys/test:keys:some/copy')\n                .query({ env: testConnectionId })\n                .send({})\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('POST /api/keys/:key/zadd', () => {\n        test('should add members to sorted set', async () => {\n            const members = [\n                { score: 1, value: 'member1' },\n                { score: 2, value: 'member2' },\n                { score: 3, value: 'member3' }\n            ];\n\n            const response = await request(app)\n                .post('/api/keys/test:keys:zset/zadd')\n                .query({ env: testConnectionId })\n                .send({ members })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('success', true);\n            expect(response.body).toHaveProperty('key', 'test:keys:zset');\n            expect(response.body.membersAdded).toBeGreaterThan(0);\n\n            const exists = await keyExists('test:keys:zset', testConnectionId);\n            expect(exists).toBe(true);\n        });\n\n        test('should add sorted set with expiry', async () => {\n            const members = [{ score: 10, value: 'item1' }];\n\n            const response = await request(app)\n                .post('/api/keys/test:keys:zset-exp/zadd')\n                .query({ env: testConnectionId })\n                .send({ members, expiry: 60 })\n                .expect(200);\n\n            expect(response.body.success).toBe(true);\n\n            const ttl = await getKeyTTL('test:keys:zset-exp', testConnectionId);\n            expect(ttl).toBeGreaterThan(0);\n            expect(ttl).toBeLessThanOrEqual(60);\n        });\n\n        test('should return 400 for invalid members', async () => {\n            const response = await request(app)\n                .post('/api/keys/test:keys:zset-bad/zadd')\n                .query({ env: testConnectionId })\n                .send({ members: [] })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should return 400 for member without score', async () => {\n            const response = await request(app)\n                .post('/api/keys/test:keys:zset-bad2/zadd')\n                .query({ env: testConnectionId })\n                .send({ members: [{ value: 'test' }] })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/__tests__/routes/keys.test.js b/__tests__/routes/keys.test.js
--- a/__tests__/routes/keys.test.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/__tests__/routes/keys.test.js	(date 1767097216752)
@@ -576,3 +576,4 @@
         });
     });
 });
+
Index: public/js/plugins/ComponentHelper.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>export class ComponentHelper {\n    static async injectHTML(htmlPath, priority = 0) {\n        try {\n            const response = await fetch(htmlPath);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch HTML: ${response.statusText}`);\n            }\n\n            const html = await response.text();\n            const mainElement = document.querySelector('main');\n\n            if (!mainElement) {\n                throw new Error('Main element not found');\n            }\n\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = html.trim();\n            const section = tempDiv.firstElementChild;\n\n            section.dataset.priority = priority;\n            mainElement.appendChild(section);\n\n            return section;\n        } catch (error) {\n            console.error('Error injecting HTML:', error);\n            throw error;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/js/plugins/ComponentHelper.js b/public/js/plugins/ComponentHelper.js
--- a/public/js/plugins/ComponentHelper.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/public/js/plugins/ComponentHelper.js	(date 1767097216752)
@@ -27,3 +27,4 @@
         }
     }
 }
+
Index: CONTRIBUTING.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Contributing to RedisDeck\n\nFirst and foremost: Thank you for your interest in contributing to RedisDeck!\nThis document provides guidelines and instructions for contributing.\n\n## Getting Started\n\n1. Fork the repository\n2. Clone your fork: `git clone https://github.com/your-username/redis-cluster-ui.git`\n3. Create a branch: `git checkout -b feature/your-feature-name`\n4. Install dependencies: `npm install`\n5. Make your changes\n6. Test your changes\n7. Commit your changes: `git commit -m \"Add: description of your changes\"`\n8. Push to your fork: `git push origin feature/your-feature-name`\n9. Create a Pull Request\n\n## Development Setup\n\n1. Copy `.env.example` to `.env` and configure your Redis connection\n2. Run the development server: `npm run dev`\n3. Access the UI at `http://localhost:3000`\n\n## Code Style\n\n- Use consistent indentation (spaces, not tabs)\n- Follow existing code patterns\n- Keep functions focused and small\n- Use meaningful variable and function names\n- Avoid unnecessary comments - code should be self-documenting\n\n## Commit Messages\n\nUse clear, descriptive commit messages:\n\n- `Add: feature description` - for new features\n- `Fix: bug description` - for bug fixes\n- `Update: what was updated` - for updates to existing features\n- `Refactor: what was refactored` - for code refactoring\n- `Docs: what documentation was updated` - for documentation changes\n\n## Pull Request Process\n\n1. Ensure your code follows the project's style guidelines\n2. Test your changes thoroughly\n3. Update documentation if needed\n4. Write a clear PR description explaining:\n    - What changes were made\n    - Why the changes were made\n    - How to test the changes\n5. Reference any related issues\n\n## Reporting Bugs\n\nWhen reporting bugs, please include:\n\n- Description of the bug\n- Steps to reproduce\n- Expected behavior\n- Actual behavior\n- Environment details (OS, Node.js version, Redis version)\n- Screenshots if applicable\n\n## Feature Requests\n\nFor feature requests, please describe:\n\n- The feature you'd like to see\n- Use case or problem it would solve\n- Any implementation ideas (optional)\n\n## Questions?\n\nFeel free to open an issue for any questions or discussions.\n\nThank you for contributing!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
--- a/CONTRIBUTING.md	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/CONTRIBUTING.md	(date 1767097216752)
@@ -74,3 +74,4 @@
 Feel free to open an issue for any questions or discussions.
 
 Thank you for contributing!
+
Index: __tests__/routes/info.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const request = require('supertest');\nconst { createApp } = require('../../config/app');\nconst {\n    createTestKey,\n    deleteTestKeys,\n    keyExists\n} = require('../helpers/testHelpers');\n\ndescribe('Info Routes', () => {\n    const app = createApp();\n    const testConnectionId = global.TEST_CONNECTION_ID;\n\n    beforeEach(async () => {\n        await deleteTestKeys('test:info:*', testConnectionId);\n    });\n\n    afterEach(async () => {\n        await deleteTestKeys('test:info:*', testConnectionId);\n    });\n\n    describe('GET /api/info', () => {\n        test('should return Redis server info', async () => {\n            const response = await request(app)\n                .get('/api/info')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toBeDefined();\n            expect(typeof response.body).toBe('object');\n        });\n\n        test('should return info sections', async () => {\n            const response = await request(app)\n                .get('/api/info')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('server');\n        });\n\n        test('should include redis version in server section', async () => {\n            const response = await request(app)\n                .get('/api/info')\n                .query({ env: testConnectionId })\n                .expect(200);\n\n            if (response.body.server) {\n                expect(response.body.server).toHaveProperty('redis_version');\n            }\n        });\n    });\n\n    describe('POST /api/flush', () => {\n        test('should flush database with confirmation', async () => {\n            await createTestKey('test:info:flush', 'value', testConnectionId);\n\n            const response = await request(app)\n                .post('/api/flush')\n                .query({ env: testConnectionId })\n                .send({ confirm: true })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('message');\n            expect(response.body).toHaveProperty('db', testConnectionId);\n\n            const exists = await keyExists('test:info:flush', testConnectionId);\n            expect(exists).toBe(false);\n        });\n\n        test('should return 400 without confirmation', async () => {\n            const response = await request(app)\n                .post('/api/flush')\n                .query({ env: testConnectionId })\n                .send({})\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should return 400 with confirm: false', async () => {\n            const response = await request(app)\n                .post('/api/flush')\n                .query({ env: testConnectionId })\n                .send({ confirm: false })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('POST /api/exec', () => {\n        test('should execute arbitrary Redis command', async () => {\n            const response = await request(app)\n                .post('/api/exec')\n                .send({\n                    command: 'PING',\n                    env: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('result');\n            expect(response.body.result).toBe('PONG');\n        });\n\n        test('should execute SET command', async () => {\n            const response = await request(app)\n                .post('/api/exec')\n                .send({\n                    command: 'SET \"test:info:exec\" \"exec-value\"',\n                    env: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body.result).toBe('OK');\n\n            const exists = await keyExists('test:info:exec', testConnectionId);\n            expect(exists).toBe(true);\n        });\n\n        test('should execute GET command', async () => {\n            await createTestKey(\n                'test:info:execget',\n                'get-value',\n                testConnectionId\n            );\n\n            const response = await request(app)\n                .post('/api/exec')\n                .send({\n                    command: '--raw GET \"test:info:execget\"',\n                    env: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body.result.trim()).toBe('get-value');\n        });\n\n        test('should return 400 when command is missing', async () => {\n            const response = await request(app)\n                .post('/api/exec')\n                .send({ env: testConnectionId })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should handle invalid commands gracefully', async () => {\n            const response = await request(app)\n                .post('/api/exec')\n                .send({\n                    command: 'INVALID_COMMAND',\n                    env: testConnectionId\n                })\n                .expect(500);\n\n            expect(response.body).toHaveProperty('error');\n        });\n    });\n\n    describe('POST /api/copy-key', () => {\n        test('should copy string key between environments', async () => {\n            await createTestKey(\n                'test:info:copykey',\n                'copy-value',\n                testConnectionId\n            );\n\n            const response = await request(app)\n                .post('/api/copy-key')\n                .send({\n                    sourceKey: 'test:info:copykey',\n                    targetKey: 'test:info:copytarget',\n                    sourceEnv: testConnectionId,\n                    targetEnv: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body).toHaveProperty('message');\n            expect(response.body.message).toContain('successfully');\n\n            const targetExists = await keyExists(\n                'test:info:copytarget',\n                testConnectionId\n            );\n            expect(targetExists).toBe(true);\n\n            await deleteTestKeys('test:info:copytarget', testConnectionId);\n        });\n\n        test('should return 400 when required fields are missing', async () => {\n            const response = await request(app)\n                .post('/api/copy-key')\n                .send({\n                    sourceKey: 'test:key'\n                })\n                .expect(400);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should return 404 when source key does not exist', async () => {\n            const response = await request(app)\n                .post('/api/copy-key')\n                .send({\n                    sourceKey: 'test:info:nonexistent',\n                    targetKey: 'test:info:target',\n                    sourceEnv: testConnectionId,\n                    targetEnv: testConnectionId\n                })\n                .expect(404);\n\n            expect(response.body).toHaveProperty('error');\n        });\n\n        test('should handle keys with TTL', async () => {\n            await createTestKey(\n                'test:info:copykey-ttl',\n                'value',\n                testConnectionId,\n                120\n            );\n\n            const response = await request(app)\n                .post('/api/copy-key')\n                .send({\n                    sourceKey: 'test:info:copykey-ttl',\n                    targetKey: 'test:info:copytarget-ttl',\n                    sourceEnv: testConnectionId,\n                    targetEnv: testConnectionId\n                })\n                .expect(200);\n\n            expect(response.body.message).toContain('successfully');\n\n            await deleteTestKeys('test:info:copytarget-ttl', testConnectionId);\n        });\n    });\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/__tests__/routes/info.test.js b/__tests__/routes/info.test.js
--- a/__tests__/routes/info.test.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/__tests__/routes/info.test.js	(date 1767097216752)
@@ -236,3 +236,4 @@
         });
     });
 });
+
Index: public/js/plugins/keyOperations/keyOperations.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { PluginBase } from '../PluginBase.js';\nimport { ComponentHelper } from '../ComponentHelper.js';\nimport { saveKey, addToSortedSet } from '../../services/apiService.js';\nimport { showToast } from '../../utils/domUtils.js';\n\nexport default class KeyOperationsPlugin extends PluginBase {\n    async init(context) {\n        this.context = context;\n        await ComponentHelper.injectHTML(\n            '/js/plugins/keyOperations/view.html',\n            this.priority\n        );\n        this.setupEventListeners();\n    }\n\n    setupEventListeners() {\n        const addKeyBtn = document.getElementById('add-key-btn');\n        const keyTypeSelect = document.getElementById('key-type');\n        const addZsetMemberBtn = document.getElementById('add-zset-member-btn');\n\n        if (!addKeyBtn || !keyTypeSelect) {\n            console.error('Key operations plugin elements not found');\n            return;\n        }\n\n        this.showTypeFields('string');\n\n        keyTypeSelect.addEventListener('change', (e) => {\n            this.showTypeFields(e.target.value);\n        });\n\n        addKeyBtn.addEventListener('click', () => {\n            this.handleAddOrUpdateKey();\n        });\n\n        if (addZsetMemberBtn) {\n            addZsetMemberBtn.addEventListener('click', () => {\n                this.addZsetMember();\n            });\n        }\n\n        document.addEventListener('click', (e) => {\n            if (e.target.classList.contains('remove-member-btn')) {\n                this.removeZsetMember(e.target);\n            }\n        });\n    }\n\n    async handleAddOrUpdateKey() {\n        const newKeyInput = document.getElementById('new-key');\n        const expiryInput = document.getElementById('expiry');\n        const keyTypeSelect = document.getElementById('key-type');\n\n        const key = newKeyInput.value.trim();\n        const keyType = keyTypeSelect.value;\n        const expiry = expiryInput.value.trim();\n\n        if (!key) {\n            showToast('Key is required', 'error');\n            return;\n        }\n\n        try {\n            const environment = this.context.getCurrentEnvironment();\n\n            if (keyType === 'string') {\n                const newValueInput = document.getElementById('new-value');\n                const value = newValueInput.value.trim();\n\n                if (!value) {\n                    showToast('Value is required', 'error');\n                    return;\n                }\n\n                await saveKey(key, value, expiry, environment);\n                newValueInput.value = '';\n            } else if (keyType === 'zset') {\n                const members = this.getZsetMembers();\n\n                if (members.length === 0) {\n                    showToast(\n                        'At least one member is required for a sorted set',\n                        'error'\n                    );\n                    return;\n                }\n\n                await addToSortedSet(key, members, expiry, environment);\n                this.clearZsetMembers();\n            } else {\n                showToast(\n                    `Support for ${keyType} keys is not implemented yet`,\n                    'error'\n                );\n                return;\n            }\n\n            showToast(`Key \"${key}\" saved successfully`, 'success');\n\n            newKeyInput.value = '';\n            expiryInput.value = '';\n\n            if (this.context.onOperationComplete) {\n                this.context.onOperationComplete();\n            }\n        } catch (error) {\n            showToast(error.message, 'error');\n            console.error('Error saving key:', error);\n        }\n    }\n\n    showTypeFields(keyType) {\n        const allTypeFields = document.querySelectorAll('.type-fields');\n        allTypeFields.forEach((field) => field.classList.add('hidden'));\n\n        const targetField = document.getElementById(`${keyType}-fields`);\n        if (targetField) {\n            targetField.classList.remove('hidden');\n        }\n    }\n\n    addZsetMember() {\n        const membersContainer = document.getElementById('zset-members');\n        const memberDiv = document.createElement('div');\n        memberDiv.className = 'zset-member';\n\n        memberDiv.innerHTML = `\n            <input type=\"number\" class=\"zset-score\" placeholder=\"Score\" step=\"any\">\n            <input type=\"text\" class=\"zset-value\" placeholder=\"Value\">\n            <button type=\"button\" class=\"remove-member-btn secondary-btn\" title=\"Remove member\">×</button>\n        `;\n\n        membersContainer.appendChild(memberDiv);\n    }\n\n    removeZsetMember(button) {\n        const memberDiv = button.closest('.zset-member');\n        const membersContainer = document.getElementById('zset-members');\n\n        if (membersContainer.children.length > 1) {\n            memberDiv.remove();\n        } else {\n            showToast('At least one member is required', 'error');\n        }\n    }\n\n    getZsetMembers() {\n        const members = [];\n        const memberDivs = document.querySelectorAll('.zset-member');\n\n        memberDivs.forEach((memberDiv) => {\n            const scoreInput = memberDiv.querySelector('.zset-score');\n            const valueInput = memberDiv.querySelector('.zset-value');\n\n            const score = scoreInput.value.trim();\n            const value = valueInput.value.trim();\n\n            if (score !== '' && value !== '') {\n                members.push({\n                    score: parseFloat(score),\n                    value: value\n                });\n            }\n        });\n\n        return members;\n    }\n\n    clearZsetMembers() {\n        const membersContainer = document.getElementById('zset-members');\n        membersContainer.innerHTML = `\n            <div class=\"zset-member\">\n                <input type=\"number\" class=\"zset-score\" placeholder=\"Score\" step=\"any\">\n                <input type=\"text\" class=\"zset-value\" placeholder=\"Value\">\n                <button type=\"button\" class=\"remove-member-btn secondary-btn\" title=\"Remove member\">×</button>\n            </div>\n        `;\n    }\n\n    async destroy() {}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/js/plugins/keyOperations/keyOperations.js b/public/js/plugins/keyOperations/keyOperations.js
--- a/public/js/plugins/keyOperations/keyOperations.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/public/js/plugins/keyOperations/keyOperations.js	(date 1767097216752)
@@ -179,3 +179,4 @@
 
     async destroy() {}
 }
+
Index: public/js/components/emptyState.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\n * Empty State Component\n * Displays when no Redis connections are configured\n */\n\nexport function init() {\n    const emptyStateHTML = `\n        <div class=\"empty-state-content\">\n            <div class=\"empty-state-icon\">\n                <svg width=\"120\" height=\"120\" viewBox=\"0 0 120 120\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <rect x=\"10\" y=\"30\" width=\"100\" height=\"70\" rx=\"8\" fill=\"var(--bg-card)\" stroke=\"var(--border-primary)\" stroke-width=\"3\"/>\n                    <line x1=\"35\" y1=\"40\" x2=\"35\" y2=\"90\" stroke=\"var(--border-secondary)\" stroke-width=\"2\"/>\n                    <line x1=\"60\" y1=\"40\" x2=\"60\" y2=\"90\" stroke=\"var(--border-secondary)\" stroke-width=\"2\"/>\n                    <line x1=\"85\" y1=\"40\" x2=\"85\" y2=\"90\" stroke=\"var(--border-secondary)\" stroke-width=\"2\"/>\n                    <line x1=\"20\" y1=\"55\" x2=\"100\" y2=\"55\" stroke=\"var(--border-secondary)\" stroke-width=\"2\"/>\n                    <line x1=\"20\" y1=\"75\" x2=\"100\" y2=\"75\" stroke=\"var(--border-secondary)\" stroke-width=\"2\"/>\n                    <circle cx=\"35\" cy=\"55\" r=\"5\" fill=\"var(--text-tertiary)\" opacity=\"0.3\"/>\n                    <circle cx=\"60\" cy=\"55\" r=\"5\" fill=\"var(--text-tertiary)\" opacity=\"0.3\"/>\n                    <circle cx=\"85\" cy=\"55\" r=\"5\" fill=\"var(--text-tertiary)\" opacity=\"0.3\"/>\n                    <circle cx=\"35\" cy=\"75\" r=\"5\" fill=\"var(--text-tertiary)\" opacity=\"0.3\"/>\n                    <circle cx=\"60\" cy=\"75\" r=\"5\" fill=\"var(--text-tertiary)\" opacity=\"0.3\"/>\n                    <circle cx=\"85\" cy=\"75\" r=\"5\" fill=\"var(--text-tertiary)\" opacity=\"0.3\"/>\n                    <line x1=\"50\" y1=\"10\" x2=\"70\" y2=\"10\" stroke=\"var(--text-tertiary)\" stroke-width=\"3\" stroke-linecap=\"round\" opacity=\"0.5\"/>\n                    <line x1=\"60\" y1=\"0\" x2=\"60\" y2=\"20\" stroke=\"var(--text-tertiary)\" stroke-width=\"3\" stroke-linecap=\"round\" opacity=\"0.5\"/>\n                </svg>\n            </div>\n            <h2 class=\"empty-state-title\">No Redis Connections</h2>\n            <p class=\"empty-state-description\">\n                Get started by adding your first Redis connection.<br>\n                You'll be able to browse keys, manage data, and monitor your Redis instances.\n            </p>\n            <button id=\"add-first-connection-btn\" class=\"add-connection-btn\">\n                <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                    <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                </svg>\n                Add Connection\n            </button>\n        </div>\n    `;\n\n    const emptyStateContainer = document.getElementById('empty-state');\n    emptyStateContainer.innerHTML = emptyStateHTML;\n\n    const addConnectionBtn = document.getElementById(\n        'add-first-connection-btn'\n    );\n    addConnectionBtn.addEventListener('click', () => {\n        window.location.href = '/settings.html';\n    });\n}\n\nexport function show() {\n    const emptyState = document.getElementById('empty-state');\n    emptyState.style.display = 'flex';\n}\n\nexport function hide() {\n    const emptyState = document.getElementById('empty-state');\n    emptyState.style.display = 'none';\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/js/components/emptyState.js b/public/js/components/emptyState.js
--- a/public/js/components/emptyState.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/public/js/components/emptyState.js	(date 1767097216752)
@@ -59,3 +59,4 @@
     const emptyState = document.getElementById('empty-state');
     emptyState.style.display = 'none';
 }
+
Index: public/js/plugins/batchDelete/view.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><section class=\"batch-operations-section\">\n    <h2>Batch Delete Keys</h2>\n    <div class=\"form-group\">\n        <label for=\"delete-pattern\">Key Pattern:</label>\n        <input\n            type=\"text\"\n            id=\"delete-pattern\"\n            placeholder=\"Enter pattern to match keys for deletion (e.g., temp:*)\"\n        />\n    </div>\n    <button id=\"batch-delete-btn\" class=\"danger-btn\">\n        Delete Matching Keys\n    </button>\n</section>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/js/plugins/batchDelete/view.html b/public/js/plugins/batchDelete/view.html
--- a/public/js/plugins/batchDelete/view.html	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/public/js/plugins/batchDelete/view.html	(date 1767097216747)
@@ -12,3 +12,4 @@
         Delete Matching Keys
     </button>
 </section>
+
Index: .prettierignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>node_modules/\ncoverage/\ndist/\nbuild/\n*.min.js\n*.min.css\npackage-lock.json\nyarn.lock\n.git/\n.vscode/\n.idea/\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.prettierignore b/.prettierignore
--- a/.prettierignore	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/.prettierignore	(date 1767097216694)
@@ -9,3 +9,4 @@
 .git/
 .vscode/
 .idea/
+
Index: __tests__/helpers/testHelpers.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const { execRedisCommand } = require('../../services/redis');\n\nasync function createTestKey(\n    key,\n    value,\n    connectionId = global.TEST_CONNECTION_ID,\n    ttl = null\n) {\n    const escapedValue = String(value)\n        .replace(/\"/g, '\\\\\"')\n        .replace(/(\\r\\n|\\n|\\r)/g, '\\\\n');\n    let command = `SET \"${key}\" \"${escapedValue}\"`;\n\n    if (ttl) {\n        command += ` EX ${ttl}`;\n    }\n\n    await execRedisCommand(command, connectionId);\n}\n\nasync function createTestHash(\n    key,\n    fields,\n    connectionId = global.TEST_CONNECTION_ID\n) {\n    for (const [field, value] of Object.entries(fields)) {\n        const escapedValue = String(value).replace(/\"/g, '\\\\\"');\n        await execRedisCommand(\n            `HSET \"${key}\" \"${field}\" \"${escapedValue}\"`,\n            connectionId\n        );\n    }\n}\n\nasync function createTestZSet(\n    key,\n    members,\n    connectionId = global.TEST_CONNECTION_ID\n) {\n    let command = `ZADD \"${key}\"`;\n    for (const { score, value } of members) {\n        const escapedValue = String(value)\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\"/g, '\\\\\"');\n        command += ` ${score} \"${escapedValue}\"`;\n    }\n    await execRedisCommand(command, connectionId);\n}\n\nasync function deleteTestKey(key, connectionId = global.TEST_CONNECTION_ID) {\n    try {\n        await execRedisCommand(`DEL \"${key}\"`, connectionId);\n    } catch (error) {\n        console.error(\n            `Warning: Could not delete test key ${key}:`,\n            error.message\n        );\n    }\n}\n\nasync function deleteTestKeys(\n    pattern,\n    connectionId = global.TEST_CONNECTION_ID\n) {\n    try {\n        const { scanClusterNodes } = require('../../services/redis');\n        const keys = [];\n        let cursors = ['0'];\n        let hasMore = true;\n\n        while (hasMore) {\n            const result = await scanClusterNodes(\n                pattern,\n                cursors,\n                10000,\n                connectionId\n            );\n            keys.push(...result.keys);\n            cursors = result.cursors;\n            hasMore = result.hasMore;\n        }\n\n        for (const key of keys) {\n            await deleteTestKey(key, connectionId);\n        }\n    } catch (error) {\n        console.error(\n            `Warning: Could not delete test keys with pattern ${pattern}:`,\n            error.message\n        );\n    }\n}\n\nasync function keyExists(key, connectionId = global.TEST_CONNECTION_ID) {\n    try {\n        const result = await execRedisCommand(`EXISTS \"${key}\"`, connectionId);\n        return parseInt(result.trim()) === 1;\n    } catch {\n        return false;\n    }\n}\n\nasync function getKeyValue(key, connectionId = global.TEST_CONNECTION_ID) {\n    try {\n        const result = await execRedisCommand(\n            `--raw GET \"${key}\"`,\n            connectionId\n        );\n        return result;\n    } catch {\n        return null;\n    }\n}\n\nasync function getKeyTTL(key, connectionId = global.TEST_CONNECTION_ID) {\n    try {\n        const result = await execRedisCommand(`TTL \"${key}\"`, connectionId);\n        return parseInt(result.trim());\n    } catch {\n        return -2;\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nmodule.exports = {\n    createTestKey,\n    createTestHash,\n    createTestZSet,\n    deleteTestKey,\n    deleteTestKeys,\n    keyExists,\n    getKeyValue,\n    getKeyTTL,\n    sleep\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/__tests__/helpers/testHelpers.js b/__tests__/helpers/testHelpers.js
--- a/__tests__/helpers/testHelpers.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/__tests__/helpers/testHelpers.js	(date 1767097216694)
@@ -136,3 +136,4 @@
     getKeyTTL,
     sleep
 };
+
Index: public/js/plugins/keyOperations/view.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><section class=\"add-key-section\">\n    <h2>Add/Update Key</h2>\n    <div class=\"form-group\">\n        <label for=\"new-key\">Key:</label>\n        <input type=\"text\" id=\"new-key\" placeholder=\"Enter key name\" />\n    </div>\n    <div class=\"form-group\">\n        <label for=\"key-type\">Type:</label>\n        <select id=\"key-type\">\n            <option value=\"string\">String</option>\n            <option value=\"zset\">Sorted Set (ZSet)</option>\n            <option value=\"hash\">Hash</option>\n            <option value=\"list\">List</option>\n            <option value=\"set\">Set</option>\n        </select>\n    </div>\n\n    <!-- String type fields -->\n    <div id=\"string-fields\" class=\"type-fields\">\n        <div class=\"form-group\">\n            <label for=\"new-value\">Value:</label>\n            <textarea id=\"new-value\" placeholder=\"Enter value\"></textarea>\n        </div>\n    </div>\n\n    <!-- ZSet type fields -->\n    <div id=\"zset-fields\" class=\"type-fields hidden\">\n        <div class=\"form-group\">\n            <label>Members (Score-Value pairs):</label>\n            <div id=\"zset-members\">\n                <div class=\"zset-member\">\n                    <input\n                        type=\"number\"\n                        class=\"zset-score\"\n                        placeholder=\"Score\"\n                        step=\"any\"\n                    />\n                    <input type=\"text\" class=\"zset-value\" placeholder=\"Value\" />\n                    <button\n                        type=\"button\"\n                        class=\"remove-member-btn secondary-btn\"\n                        title=\"Remove member\"\n                    >\n                        ×\n                    </button>\n                </div>\n            </div>\n            <button\n                type=\"button\"\n                id=\"add-zset-member-btn\"\n                class=\"secondary-btn\"\n            >\n                Add Member\n            </button>\n        </div>\n    </div>\n\n    <!-- Common fields -->\n    <div class=\"form-group\">\n        <label for=\"expiry\">Expiry (seconds, optional):</label>\n        <input\n            type=\"number\"\n            id=\"expiry\"\n            placeholder=\"Leave empty for no expiry\"\n        />\n    </div>\n    <button id=\"add-key-btn\">Save Key</button>\n</section>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/js/plugins/keyOperations/view.html b/public/js/plugins/keyOperations/view.html
--- a/public/js/plugins/keyOperations/view.html	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/public/js/plugins/keyOperations/view.html	(date 1767097216752)
@@ -66,3 +66,4 @@
     </div>
     <button id="add-key-btn">Save Key</button>
 </section>
+
Index: __tests__/services/database.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const {\n    getAllConnections,\n    getConnection,\n    createConnection,\n    updateConnection,\n    deleteConnection,\n    updateConnectionOrder,\n    getConnectionConfig\n} = require('../../services/database');\n\ndescribe('Database Service', () => {\n    const testConnectionId = 'test-db-conn-' + Date.now();\n\n    afterAll(() => {\n        try {\n            deleteConnection(testConnectionId);\n        } catch (error) {\n            console.error('Cleanup warning:', error.message);\n        }\n    });\n\n    describe('getAllConnections', () => {\n        test('should return array of connections', () => {\n            const connections = getAllConnections();\n\n            expect(Array.isArray(connections)).toBe(true);\n            expect(connections.length).toBeGreaterThan(0);\n            expect(connections[0]).toHaveProperty('id');\n            expect(connections[0]).toHaveProperty('host');\n            expect(connections[0]).toHaveProperty('port');\n        });\n\n        test('should return connections ordered by order field', () => {\n            const connections = getAllConnections();\n\n            for (let i = 0; i < connections.length - 1; i++) {\n                expect(connections[i].order).toBeLessThanOrEqual(\n                    connections[i + 1].order\n                );\n            }\n        });\n    });\n\n    describe('getConnection', () => {\n        test('should return connection by id', () => {\n            const connections = getAllConnections();\n            const firstConnection = connections[0];\n\n            const connection = getConnection(firstConnection.id);\n\n            expect(connection).toBeDefined();\n            expect(connection.id).toBe(firstConnection.id);\n            expect(connection).toHaveProperty('host');\n            expect(connection).toHaveProperty('port');\n            expect(connection).toHaveProperty('password');\n        });\n\n        test('should return undefined for non-existent connection', () => {\n            const connection = getConnection('non-existent-connection-id');\n\n            expect(connection).toBeUndefined();\n        });\n    });\n\n    describe('createConnection', () => {\n        test('should create new connection with required fields', () => {\n            const newConnection = {\n                id: testConnectionId,\n                host: '127.0.0.1',\n                port: 6380\n            };\n\n            const success = createConnection(newConnection);\n\n            expect(success).toBe(true);\n\n            const connection = getConnection(testConnectionId);\n            expect(connection).toBeDefined();\n            expect(connection.id).toBe(testConnectionId);\n            expect(connection.host).toBe('127.0.0.1');\n            expect(connection.port).toBe(6380);\n        });\n\n        test('should create connection with optional fields', () => {\n            const connectionId = testConnectionId + '-with-auth';\n\n            const newConnection = {\n                id: connectionId,\n                host: 'redis.example.com',\n                port: 6379,\n                username: 'testuser',\n                password: 'testpass',\n                tls: true,\n                cluster: true\n            };\n\n            const success = createConnection(newConnection);\n            expect(success).toBe(true);\n\n            const connection = getConnection(connectionId);\n            expect(connection.username).toBe('testuser');\n            expect(connection.password).toBe('testpass');\n            expect(connection.tls).toBe(1);\n            expect(connection.cluster).toBe(1);\n\n            deleteConnection(connectionId);\n        });\n\n        test('should assign order to new connection', () => {\n            const connectionId = testConnectionId + '-order-test';\n            const newConnection = {\n                id: connectionId,\n                host: '127.0.0.1',\n                port: 6381\n            };\n\n            const success = createConnection(newConnection);\n            expect(success).toBe(true);\n\n            const connection = getConnection(connectionId);\n            expect(connection.order).toBeDefined();\n            expect(typeof connection.order).toBe('number');\n\n            deleteConnection(connectionId);\n        });\n    });\n\n    describe('updateConnection', () => {\n        test('should update existing connection', () => {\n            const updateData = {\n                host: 'updated-host.example.com',\n                port: 6382,\n                username: 'updateduser',\n                password: 'updatedpass',\n                tls: true,\n                cluster: false\n            };\n\n            const success = updateConnection(testConnectionId, updateData);\n            expect(success).toBe(true);\n\n            const connection = getConnection(testConnectionId);\n            expect(connection.host).toBe('updated-host.example.com');\n            expect(connection.port).toBe(6382);\n            expect(connection.username).toBe('updateduser');\n            expect(connection.tls).toBe(1);\n            expect(connection.cluster).toBe(0);\n        });\n\n        test('should return false for non-existent connection', () => {\n            const success = updateConnection('non-existent-id', {\n                host: 'localhost',\n                port: 6379\n            });\n\n            expect(success).toBe(false);\n        });\n    });\n\n    describe('updateConnectionOrder', () => {\n        test('should update connection order', () => {\n            const connections = getAllConnections();\n            const connectionIds = connections.map((conn) => conn.id);\n\n            const reversedIds = [...connectionIds].reverse();\n\n            updateConnectionOrder(reversedIds);\n\n            const updatedConnections = getAllConnections();\n            expect(updatedConnections[0].id).toBe(reversedIds[0]);\n            expect(updatedConnections[updatedConnections.length - 1].id).toBe(\n                reversedIds[reversedIds.length - 1]\n            );\n\n            updateConnectionOrder(connectionIds);\n        });\n    });\n\n    describe('deleteConnection', () => {\n        test('should delete existing connection', () => {\n            const connectionId = testConnectionId + '-to-delete';\n            createConnection({\n                id: connectionId,\n                host: 'localhost',\n                port: 6379\n            });\n\n            const success = deleteConnection(connectionId);\n            expect(success).toBe(true);\n\n            const connection = getConnection(connectionId);\n            expect(connection).toBeUndefined();\n        });\n\n        test('should return false for non-existent connection', () => {\n            const success = deleteConnection('non-existent-connection');\n            expect(success).toBe(false);\n        });\n    });\n\n    describe('getConnectionConfig', () => {\n        test('should return config object for connection', () => {\n            const config = getConnectionConfig(testConnectionId);\n\n            expect(config).toBeDefined();\n            expect(config).toHaveProperty('host');\n            expect(config).toHaveProperty('port');\n            expect(config.host).toBe('updated-host.example.com');\n            expect(config.port).toBe(6382);\n        });\n\n        test('should throw error for non-existent connection', () => {\n            expect(() => {\n                getConnectionConfig('non-existent-connection');\n            }).toThrow(\"Connection 'non-existent-connection' not found\");\n        });\n\n        test('should convert tls and cluster flags to boolean', () => {\n            const config = getConnectionConfig(testConnectionId);\n\n            expect(typeof config.tls).toBe('boolean');\n            expect(typeof config.cluster).toBe('boolean');\n        });\n    });\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/__tests__/services/database.test.js b/__tests__/services/database.test.js
--- a/__tests__/services/database.test.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/__tests__/services/database.test.js	(date 1767097216752)
@@ -223,3 +223,4 @@
         });
     });
 });
+
Index: public/js/plugins/batchDelete/batchDelete.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { PluginBase } from '../PluginBase.js';\nimport { ComponentHelper } from '../ComponentHelper.js';\nimport { deleteKeysByPattern } from '../../services/apiService.js';\nimport { showToast } from '../../utils/domUtils.js';\n\nexport default class BatchDeletePlugin extends PluginBase {\n    async init(context) {\n        this.context = context;\n        await ComponentHelper.injectHTML(\n            '/js/plugins/batchDelete/view.html',\n            this.priority\n        );\n        this.setupEventListeners();\n    }\n\n    setupEventListeners() {\n        const batchDeleteBtn = document.getElementById('batch-delete-btn');\n        const deletePattern = document.getElementById('delete-pattern');\n\n        if (!batchDeleteBtn || !deletePattern) {\n            console.error('Batch delete plugin elements not found');\n            return;\n        }\n\n        batchDeleteBtn.addEventListener('click', () => {\n            this.handleBatchDelete();\n        });\n\n        deletePattern.addEventListener('keyup', (e) => {\n            if (e.key === 'Enter') {\n                this.handleBatchDelete();\n            }\n        });\n    }\n\n    async handleBatchDelete() {\n        const deletePattern = document.getElementById('delete-pattern');\n        const pattern = deletePattern.value.trim();\n\n        if (!pattern) {\n            showToast('Pattern is required', 'error');\n            return;\n        }\n\n        if (\n            !confirm(\n                `Are you sure you want to delete all keys matching the pattern \"${pattern}\"?`\n            )\n        ) {\n            return;\n        }\n\n        try {\n            const environment = this.context.getCurrentEnvironment();\n            const result = await deleteKeysByPattern(pattern, environment);\n            showToast(result.message, 'success');\n\n            deletePattern.value = '';\n\n            if (this.context.onOperationComplete) {\n                this.context.onOperationComplete();\n            }\n        } catch (error) {\n            showToast(error.message, 'error');\n            console.error('Error deleting keys:', error);\n        }\n    }\n\n    async destroy() {}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/js/plugins/batchDelete/batchDelete.js b/public/js/plugins/batchDelete/batchDelete.js
--- a/public/js/plugins/batchDelete/batchDelete.js	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/public/js/plugins/batchDelete/batchDelete.js	(date 1767097216752)
@@ -68,3 +68,4 @@
 
     async destroy() {}
 }
+
Index: LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>MIT License\n\nCopyright (c) 2025 RedisDeck Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LICENSE b/LICENSE
--- a/LICENSE	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/LICENSE	(date 1767097216694)
@@ -24,3 +24,4 @@
 
 
 
+
Index: __tests__/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Backend Functional Tests\n\nThis directory contains comprehensive functional tests for the Redis UI backend application. All tests use real Redis connections to ensure full integration testing.\n\n## Test Structure\n\n```\n__tests__/\n├── setup.js                    # Global test setup and teardown\n├── helpers/\n│   └── testHelpers.js         # Utility functions for test data management\n├── services/\n│   ├── database.test.js       # Database service tests\n│   └── redis.test.js          # Redis service tests\n└── routes/\n    ├── connections.test.js    # Connection management API tests\n    ├── keys.test.js           # Key operations API tests\n    ├── info.test.js           # Redis info and admin API tests\n    ├── environment.test.js    # Environment API tests\n    └── custom.test.js         # Custom command execution API tests\n```\n\n## Running Tests\n\n### Prerequisites\n\n1. Redis server must be running and accessible\n2. Install dependencies:\n\n```bash\nyarn install\n```\n\n### Environment Variables\n\nConfigure test Redis connection via environment variables (optional):\n\n```bash\nREDIS_TEST_HOST=127.0.0.1\nREDIS_TEST_PORT=6379\nREDIS_TEST_USER=\nREDIS_TEST_PASSWORD=\nREDIS_TEST_TLS=false\nREDIS_TEST_CLUSTER=false\n```\n\nDefault values connect to local Redis on port 6379.\n\n### Run All Tests\n\n```bash\nyarn test\n```\n\n### Run Specific Test Suite\n\n```bash\nyarn test database.test.js\nyarn test redis.test.js\nyarn test connections.test.js\n```\n\n### Run Tests in Watch Mode\n\n```bash\nyarn test:watch\n```\n\n### Run Tests with Coverage\n\n```bash\nyarn test --coverage\n```\n\n## Test Features\n\n### Functional Testing\n\n- All tests use real Redis connections\n- Tests perform actual database operations\n- Full integration testing of API endpoints\n\n### Test Isolation\n\n- Each test uses unique key prefixes\n- Automatic cleanup of test data after each test\n- Test connection managed in global setup\n\n### Comprehensive Coverage\n\n#### Database Service Tests\n\n- CRUD operations for connections\n- Connection ordering\n- Configuration management\n\n#### Redis Service Tests\n\n- Command execution with real Redis\n- Key operations (SET, GET, DEL, etc.)\n- Hash operations\n- Sorted set operations\n- TTL and expiry management\n- Cluster-aware operations\n- SCAN operations with pagination\n- INFO parsing\n\n#### Route Tests\n\n- All HTTP endpoints tested\n- Request validation\n- Response format verification\n- Error handling\n- Real Redis data operations\n\n## Test Data Management\n\nTest data uses the `test:*` key prefix pattern for easy identification and cleanup.\n\n### Helper Functions\n\nThe `testHelpers.js` module provides utilities for:\n\n- Creating test keys with various data types\n- Managing test data lifecycle\n- Checking key existence\n- Reading key values\n- Managing TTLs\n\n## Best Practices\n\n1. **Test Isolation**: Each test cleans up after itself\n2. **Real Connections**: Tests connect to actual Redis instances\n3. **Descriptive Names**: Test names clearly describe what they verify\n4. **Comprehensive Assertions**: Multiple assertions verify complete behavior\n5. **Error Handling**: Tests verify both success and error cases\n\n## Troubleshooting\n\n### Connection Errors\n\nIf tests fail with connection errors:\n\n1. Verify Redis is running: `redis-cli ping`\n2. Check Redis host/port configuration\n3. Ensure Redis accepts connections from test environment\n\n### Test Cleanup\n\nIf tests leave data behind:\n\n```bash\nredis-cli --scan --pattern \"test:*\" | xargs redis-cli del\n```\n\n### Test Timeout\n\nIf tests timeout, increase Jest timeout in `jest.config.js`:\n\n```javascript\ntestTimeout: 30000; // 30 seconds\n```\n\n## Contributing\n\nWhen adding new tests:\n\n1. Follow existing test structure\n2. Use test helper functions for data management\n3. Clean up test data in afterEach hooks\n4. Use descriptive test names\n5. Test both success and error cases\n6. Ensure tests work with real Redis connections\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/__tests__/README.md b/__tests__/README.md
--- a/__tests__/README.md	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/__tests__/README.md	(date 1767097216752)
@@ -171,3 +171,4 @@
 4. Use descriptive test names
 5. Test both success and error cases
 6. Ensure tests work with real Redis connections
+
Index: SECURITY.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Security Policy\n\n## Supported Versions\n\nWe provide security updates for the following versions:\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 1.x.x   | :white_check_mark: |\n\n## Reporting a Vulnerability\n\nIf you discover a security vulnerability, please **do not** open a public issue. Instead, please report it via one of the following methods:\n\n1. **Email**: Send details to [your-email@example.com] (replace with your actual email)\n2. **GitHub Security Advisory**: Use GitHub's private vulnerability reporting feature if available\n\n### What to Include\n\nWhen reporting a vulnerability, please include:\n\n- Description of the vulnerability\n- Steps to reproduce\n- Potential impact\n- Suggested fix (if any)\n\n### Response Timeline\n\n- We will acknowledge receipt within 48 hours\n- We will provide an initial assessment within 7 days\n- We will keep you informed of our progress\n\n### Security Best Practices\n\nWhen using this tool:\n\n- Never commit `.env` files with real credentials\n- Use environment variables for sensitive configuration\n- Run the application in a secure network environment\n- Keep Redis instances protected with authentication\n- Use TLS when connecting to remote Redis instances\n- Regularly update dependencies: `npm audit` and `npm audit fix`\n\n## Security Considerations\n\nThis tool provides direct access to Redis instances. Please ensure:\n\n- The application is not exposed to untrusted networks\n- Redis authentication is properly configured\n- Network access is restricted appropriately\n- Regular security audits are performed\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SECURITY.md b/SECURITY.md
--- a/SECURITY.md	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/SECURITY.md	(date 1767097216752)
@@ -49,3 +49,4 @@
 - Redis authentication is properly configured
 - Network access is restricted appropriately
 - Regular security audits are performed
+
Index: CHANGELOG.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n\n- Initial release\n- Web UI for Redis cluster management\n- Key search and filtering\n- Key CRUD operations (Create, Read, Update, Delete)\n- Support for multiple Redis data types (String, Hash, List, Set, Sorted Set)\n- Batch delete operations\n- Connection management\n- Custom Redis command execution\n- TTL management\n- Key renaming and copying\n- Environment switching (staging/production)\n- Docker support\n\n### Changed\n\n- N/A\n\n### Fixed\n\n- N/A\n\n### Security\n\n- N/A\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CHANGELOG.md b/CHANGELOG.md
--- a/CHANGELOG.md	(revision 1635222f701556f66f8aabbed5364385beef3018)
+++ b/CHANGELOG.md	(date 1767097216752)
@@ -33,3 +33,4 @@
 ### Security
 
 - N/A
+
